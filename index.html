<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>FM2026 Pro Portrait - Super Stable</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; }
        .glass-panel { background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        canvas { border-radius: 35px; background: transparent; image-rendering: -webkit-optimize-contrast; }
        .cropper-view-box, .cropper-face { border-radius: 0; }
        input[type="range"] { accent-color: #22c55e; height: 6px; }
        .loader { border: 3px solid #f3f3f3; border-top: 3px solid #22c55e; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="h-screen flex p-6 gap-6 overflow-hidden">

    <div class="glass-panel w-80 p-6 rounded-2xl flex flex-col gap-4 overflow-y-auto">
        <div class="text-center mb-2">
            <h1 class="text-2xl font-black text-green-500 italic">FM2026 HQ</h1>
            <p id="libStatus" class="text-[10px] text-green-500 mt-1 uppercase font-bold tracking-widest">System Online</p>
        </div>

        <div class="space-y-3">
            <input type="file" id="fileInput" class="hidden" accept="image/*" multiple>
            <button onclick="document.getElementById('fileInput').click()" class="w-full bg-blue-600 hover:bg-blue-700 py-3 rounded-lg font-bold text-sm shadow-lg transition-all">1. 사진 불러오기</button>
            
            <button id="removeBgBtn" class="w-full bg-purple-600 hover:bg-purple-700 py-3 rounded-lg font-bold text-sm flex justify-center items-center gap-2 shadow-lg transition-all disabled:opacity-50">
                <span id="btnText">2. 배경 제거 (AI)</span>
                <div id="loadingSpinner" class="loader hidden"></div>
            </button>

            <p id="fileProgress" class="text-center text-[10px] text-gray-400 font-bold uppercase">Ready</p>
            <input type="text" id="playerName" placeholder="선수 이름" class="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg focus:border-green-500 outline-none uppercase text-sm font-bold">
            <input type="text" id="fileName" placeholder="파일명 (ID)" class="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg focus:border-green-500 outline-none text-sm font-bold">
        </div>

        <div class="space-y-4 pt-2">
            <div><label class="flex justify-between text-[11px] font-bold mb-1"><span>밝기 (Brightness)</span><span id="v-bright">100%</span></label><input type="range" id="bright" min="50" max="150" value="100" class="w-full"></div>
            <div><label class="flex justify-between text-[11px] font-bold mb-1 text-green-400"><span>선명도 (HD Sharpen)</span><span id="v-sharpen">0%</span></label><input type="range" id="sharpen" min="0" max="100" value="0" class="w-full"></div>
        </div>

        <button id="nextBtn" class="mt-auto bg-green-600 hover:bg-green-700 py-4 rounded-xl font-black text-lg shadow-xl transition-all">저장 및 다음</button>
    </div>

    <div class="flex-1 flex flex-col md:flex-row items-center justify-around glass-panel rounded-3xl p-8 gap-8">
        <div id="cropWrapper" class="w-full max-w-lg aspect-square bg-black/30 rounded-xl overflow-hidden shadow-2xl border border-gray-800 flex items-center justify-center text-gray-500 italic relative">
            <div id="loaderOverlay" class="absolute inset-0 bg-black/50 hidden z-50 flex items-center justify-center flex-col gap-4">
                <div class="loader w-10 h-10"></div>
                <p class="text-sm font-bold">AI가 인물 분석 중...</p>
            </div>
        </div>
        <div class="relative">
            <canvas id="outCanvas" width="260" height="310"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const playerNameInput = document.getElementById('playerName');
        const canvas = document.getElementById('outCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        let fileQueue = [];
        let currentIndex = -1;
        let cropper;
        let originalImage = null;

        // MediaPipe 초기화 (로컬 환경에서도 잘 돌아가도록 최적화)
        const selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });
        selfieSegmentation.setOptions({ modelSelection: 1 });
        selfieSegmentation.onResults(onResults);

        fileInput.onchange = (e) => {
            fileQueue = Array.from(e.target.files);
            if (fileQueue.length > 0) { currentIndex = 0; loadCurrent(); }
        };

        function loadCurrent() {
            if (currentIndex >= fileQueue.length) return;
            const file = fileQueue[currentIndex];
            document.getElementById('fileProgress').innerText = `BATCH: ${currentIndex + 1} / ${fileQueue.length}`;
            document.getElementById('fileName').value = file.name.split('.')[0];
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => { originalImage = img; setupCropper(img.src); };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCropper(url) {
            const wrapper = document.getElementById('cropWrapper');
            wrapper.innerHTML = `<img id="tgt" src="${url}" style="max-width:100%;">`;
            if(cropper) cropper.destroy();
            cropper = new Cropper(document.getElementById('tgt'), {
                aspectRatio: 260/310, viewMode: 1,
                ready() { render(); }
            });
            document.getElementById('tgt').addEventListener('crop', render);
        }

        // [핵심] 배경 제거 로직 - 리사이징을 통한 프리징 방지
        document.getElementById('removeBgBtn').onclick = async () => {
            if (!originalImage) return;
            
            document.getElementById('loaderOverlay').classList.remove('hidden');
            document.getElementById('removeBgBtn').disabled = true;

            // AI 처리를 위해 이미지 리사이징 (프리징 방지 핵심)
            const offscreen = document.createElement('canvas');
            const maxDimension = 512; // AI 분석에 충분한 크기
            let w = originalImage.width, h = originalImage.height;
            if (w > h) { if (w > maxDimension) { h *= maxDimension / w; w = maxDimension; } }
            else { if (h > maxDimension) { w *= maxDimension / h; h = maxDimension; } }
            
            offscreen.width = w; offscreen.height = h;
            offscreen.getContext('2d').drawImage(originalImage, 0, 0, w, h);

            // AI에 전송
            await selfieSegmentation.send({ image: offscreen });
        };

        function onResults(results) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.width;
            tempCanvas.height = originalImage.height;
            const tCtx = tempCanvas.getContext('2d');

            tCtx.save();
            tCtx.drawImage(results.segmentationMask, 0, 0, tempCanvas.width, tempCanvas.height);
            tCtx.globalCompositeOperation = 'source-in';
            tCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
            tCtx.restore();

            setupCropper(tempCanvas.toDataURL('image/png'));
            
            document.getElementById('loaderOverlay').classList.add('hidden');
            document.getElementById('removeBgBtn').disabled = false;
        }

        function render() {
            if (!cropper) return;
            const cropped = cropper.getCroppedCanvas({ width: 260, height: 310, imageSmoothingQuality: 'high' });
            ctx.clearRect(0, 0, 260, 310);
            ctx.save();
            drawRoundRect(ctx, 35); ctx.clip();
            ctx.drawImage(cropped, 0, 0);
            ctx.restore();

            const b = document.getElementById('bright').value / 100;
            const s = document.getElementById('sharpen').value / 100;
            let id = ctx.getImageData(0, 0, 260, 310);
            
            // 보정 로직 (알파값 보호)
            for(let i=0; i<id.data.length; i+=4) {
                if(id.data[i+3] > 10) { 
                    id.data[i]*=b; id.data[i+1]*=b; id.data[i+2]*=b; 
                }
            }
            if(s>0) id = applySharp(id, s);
            ctx.putImageData(id, 0, 0);
            
            const name = playerNameInput.value.toUpperCase();
            if(name) drawText(ctx, name);
        }

        // [핵심] 고화질 선명도 필터 (그림자 문제 해결됨)
        function applySharp(id, a) {
            const w=id.width, h=id.height, src=id.data, out=ctx.createImageData(w,h), dst=out.data;
            const k = [0, -a, 0, -a, 1+4*a, -a, 0, -a, 0];
            for(let y=1; y<h-1; y++) for(let x=1; x<w-1; x++) {
                const i = (y*w+x)*4;
                if(src[i+3] < 50) { dst[i+3]=0; continue; }
                for(let j=0; j<3; j++) {
                    let r = src[((y-1)*w+x)*4+j]*k[1] + src[(y*w+x-1)*4+j]*k[3] + src[i+j]*k[4] + src[(y*w+x+1)*4+j]*k[5] + src[((y+1)*w+x)*4+j]*k[7];
                    dst[i+j] = Math.min(255, Math.max(0, r));
                }
                dst[i+3] = src[i+3];
            }
            return out;
        }

        function drawText(ctx, text) {
            let sz = 32; ctx.font = `bold ${sz}px Impact, sans-serif`;
            while(ctx.measureText(text).width > 230 && sz > 10) ctx.font = `bold ${--sz}px Impact, sans-serif`;
            ctx.textAlign = 'center'; 
            
            // 깔끔한 8방향 외곽선
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            [[-1,-1],[1,-1],[-1,1],[1,1],[0,-1],[0,1],[-1,0],[1,0]].forEach(o => ctx.fillText(text, 130+o[0], 280+o[1]));
            
            const g = ctx.createLinearGradient(0, 250, 0, 280);
            g.addColorStop(0, '#FFEBAA'); g.addColorStop(1, '#8A6D3B');
            ctx.fillStyle = g; ctx.fillText(text, 130, 280);
        }

        function drawRoundRect(ctx, r) {
            ctx.beginPath(); ctx.moveTo(r, 0); ctx.arcTo(260,0,260,310,r); ctx.arcTo(260,310,0,310,r); ctx.arcTo(0,310,0,0,r); ctx.arcTo(0,0,260,0,r); ctx.closePath();
        }

        document.getElementById('nextBtn').onclick = () => {
            const l = document.createElement('a');
            l.download = `${document.getElementById('fileName').value}.png`;
            l.href = canvas.toDataURL('image/png', 1.0); l.click();
            if(++currentIndex < fileQueue.length) loadCurrent();
        };

        ['playerName','bright','sharpen'].forEach(id => document.getElementById(id).oninput = () => {
            if(id!=='playerName') document.getElementById(`v-${id}`).innerText = `${document.getElementById(id).value}%`;
            render();
        });
    </script>
</body>
</html>
