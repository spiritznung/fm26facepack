<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>FM2026 Final Composer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; }
        .glass-panel { background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        canvas { background: transparent; } /* 캔버스 배경 투명 고정 */
        input[type="range"] { accent-color: #22c55e; height: 6px; }
    </style>
</head>
<body class="h-screen flex p-6 gap-6 overflow-hidden">

    <div class="glass-panel w-80 p-6 rounded-2xl flex flex-col gap-6 overflow-y-auto">
        <div class="text-center">
            <h1 class="text-2xl font-black text-green-500 italic uppercase">FM2026 Composer</h1>
            <p class="text-[10px] text-gray-400 mt-1 uppercase font-bold tracking-widest">For Pre-cut Images</p>
        </div>

        <div class="space-y-3 border-b border-white/10 pb-6">
            <input type="file" id="fileInput" class="hidden" accept="image/png, image/jpeg, image/webp" multiple>
            <button onclick="document.getElementById('fileInput').click()" class="w-full bg-blue-600 hover:bg-blue-700 py-4 rounded-xl font-bold text-lg shadow-lg transition-all">1. 투명 이미지 불러오기</button>
            <p class="text-xs text-center text-gray-400">* Gemini 등으로 배경이 제거된 PNG 권장</p>
        </div>

        <div class="space-y-4">
            <input type="text" id="playerName" placeholder="선수 이름 (ENG)" class="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg focus:border-green-500 outline-none uppercase text-sm font-bold">
            <input type="text" id="fileName" placeholder="파일명 (ID 번호)" class="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg focus:border-green-500 outline-none text-sm font-bold">
            
            <div>
                <label class="flex justify-between text-[11px] font-bold mb-1"><span>밝기 (Brightness)</span><span id="v-bright">100%</span></label>
                <input type="range" id="bright" min="50" max="150" value="100" class="w-full">
            </div>
            <div>
                <label class="flex justify-between text-[11px] font-bold mb-1 text-green-400"><span>선명도 (Sharpen)</span><span id="v-sharpen">0%</span></label>
                <input type="range" id="sharpen" min="0" max="100" value="0" class="w-full">
            </div>
        </div>

        <button id="nextBtn" class="mt-auto bg-green-600 hover:bg-green-700 py-4 rounded-xl font-black text-lg shadow-xl transition-all">저장 및 다음 (PNG)</button>
    </div>

    <div class="flex-1 flex flex-col md:flex-row items-center justify-around glass-panel rounded-3xl p-8 gap-8 relative">
        <div id="cropContainer" class="w-full max-w-lg aspect-square rounded-xl overflow-hidden shadow-2xl border border-gray-800 flex items-center justify-center relative bg-gray-900">
             <div class="absolute inset-0 z-0 opacity-20" style="background-image: linear-gradient(45deg, #555 25%, transparent 25%), linear-gradient(-45deg, #555 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #555 75%), linear-gradient(-45deg, transparent 75%, #555 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;"></div>
            <div id="cropWrapper" class="relative z-10 text-gray-500 italic">준비된 이미지를 드래그하세요.</div>
        </div>
        
        <div class="flex flex-col items-center gap-4">
            <div class="px-4 py-1 bg-gray-800 rounded-full text-[10px] font-bold tracking-widest text-gray-400 border border-gray-700 uppercase">Final Output (Transparent)</div>
            <div class="relative rounded-[35px] overflow-hidden shadow-xl border border-white/10" style="background-image: linear-gradient(45deg, #555 25%, transparent 25%), linear-gradient(-45deg, #555 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #555 75%), linear-gradient(-45deg, transparent 75%, #555 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;">
                <canvas id="outCanvas" width="260" height="310" class="relative z-10"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('outCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let cropper;

        fileInput.onchange = (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) loadFile(files[0]);
        };

        function loadFile(file) {
            document.getElementById('fileName').value = file.name.split('.')[0];
            const reader = new FileReader();
            reader.onload = (ev) => {
                const wrapper = document.getElementById('cropWrapper');
                wrapper.innerHTML = `<img id="tgt" src="${ev.target.result}" style="max-width:100%;">`;
                if(cropper) cropper.destroy();
                cropper = new Cropper(document.getElementById('tgt'), {
                    aspectRatio: 260/310, viewMode: 1, ready() { render(); }
                });
                document.getElementById('tgt').addEventListener('crop', render);
            };
            reader.readAsDataURL(file);
        }

        // [핵심] 투명도를 완벽하게 보존하는 렌더링 로직
        function render() {
            if (!cropper) return;
            // 1. 크롭된 이미지 가져오기 (투명도 포함)
            const cropped = cropper.getCroppedCanvas({ width: 260, height: 310, imageSmoothingQuality: 'high' });
            
            // 2. 캔버스 초기화 (완전 투명 상태로 만듦)
            ctx.clearRect(0, 0, 260, 310);
            
            // 3. 라운드 코너 및 이미지 그리기
            ctx.save();
            drawRoundRect(ctx, 35);
            ctx.clip();
            
            // 밝기 필터 적용 (투명도에 영향 없음)
            const b = document.getElementById('bright').value;
            ctx.filter = `brightness(${b}%)`;
            ctx.drawImage(cropped, 0, 0);
            ctx.restore(); // 필터 및 클립 해제

            // 4. 선명도 적용 (알파 채널 보호 로직 포함)
            const s = document.getElementById('sharpen').value / 100;
            if(s > 0) {
                 let id = ctx.getImageData(0,0,260,310);
                 id = applySharp(id, s);
                 ctx.putImageData(id, 0,0);
            }

            // 5. 텍스트 추가
            const name = document.getElementById('playerName').value.toUpperCase();
            if(name) drawText(ctx, name);
        }

        // 선명도 필터 - 투명 영역(알파값 0)은 건드리지 않음
        function applySharp(id, a) {
            const w=id.width, h=id.height, src=id.data, out=ctx.createImageData(w,h), dst=out.data;
            const k = [0, -a, 0, -a, 1+4*a, -a, 0, -a, 0];
            for(let y=1; y<h-1; y++) for(let x=1; x<w-1; x++) {
                const i = (y*w+x)*4;
                if(src[i+3] === 0) continue; // 투명 픽셀 건너뛰기
                for(let j=0; j<3; j++) {
                    let r = src[((y-1)*w+x)*4+j]*k[1] + src[(y*w+x-1)*4+j]*k[3] + src[i+j]*k[4] + src[(y*w+x+1)*4+j]*k[5] + src[((y+1)*w+x)*4+j]*k[7];
                    dst[i+j] = Math.min(255, Math.max(0, r));
                }
                dst[i+3] = src[i+3]; // 알파값 원본 유지
            }
            return out;
        }

        function drawText(ctx, text) {
            let sz = 32; ctx.font = `bold ${sz}px Impact, sans-serif`;
            while(ctx.measureText(text).width > 230 && sz > 10) ctx.font = `bold ${--sz}px Impact, sans-serif`;
            ctx.textAlign = 'center'; 
            
            // 8방향 아웃라인 (깔끔함)
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            [[-1,-1],[1,-1],[-1,1],[1,1],[0,-1],[0,1],[-1,0],[1,0]].forEach(o => ctx.fillText(text, 130+o[0], 280+o[1]));
            
            // 골드 그라데이션
            const g = ctx.createLinearGradient(0, 250, 0, 280);
            g.addColorStop(0, '#FFEBAA'); g.addColorStop(0.5, '#D4AF37'); g.addColorStop(1, '#8A6D3B');
            ctx.fillStyle = g; ctx.fillText(text, 130, 280);
        }

        function drawRoundRect(ctx, r) {
            ctx.beginPath(); ctx.moveTo(r, 0); ctx.arcTo(260,0,260,310,r); ctx.arcTo(260,310,0,310,r); ctx.arcTo(0,310,0,0,r); ctx.arcTo(0,0,260,0,r); ctx.closePath();
        }

        // UI 이벤트 바인딩
        ['bright', 'sharpen'].forEach(id => {
            document.getElementById(id).oninput = (e) => {
                document.getElementById(`v-${id}`).innerText = e.target.value + '%';
                render();
            };
        });
        document.getElementById('playerName').oninput = render;

        // 저장 버튼 (PNG 강제)
        document.getElementById('nextBtn').onclick = () => {
            const link = document.createElement('a');
            link.download = `${document.getElementById('fileName').value || 'FM_Face'}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        };
    </script>
</body>
</html>
